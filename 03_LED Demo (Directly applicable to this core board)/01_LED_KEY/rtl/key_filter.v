/***************************************************
*	Module Name		:	key_filter		   
*	Engineer			:	小梅哥
*	Target Device	:	10CL025YU256C8
*	Tool versions	:	Quartus Prime 18.1
*	Create Date		:	2021-12-20
*	Revision			:	v1.0
*	Description		:  Однокнопочный фильтр дребезга
**************************************************/

module key_filter(
			Clk,      // 50 МГц системный тактовый сигнал
			Rst_n,    // активный низкий сигнал сброса
			key_in,   // сигнал от кнопки (асинхронный)
			key_flag, // флаг нажатия/отпускания кнопки (один импульс)
			key_state // текущее состояние кнопки: 0 – нажата, 1 – отпущена
		);

	input Clk;
	input Rst_n;
	input key_in;
	
	output reg key_flag;   // однократный импульс при изменении состояния
	output reg key_state;  // стабильное состояние кнопки после фильтрации
	
	// Состояния конечного автомата (FSM)
	localparam
		IDLE		= 4'b0001,  // ожидание изменения
		FILTER0	= 4'b0010,  // фильтрация при нажатии
		DOWN		= 4'b0100,  // кнопка удерживается
		FILTER1 	= 4'b1000;  // фильтрация при отпускании
		
	reg [3:0] state;      // текущее состояние FSM
	reg [19:0] cnt;       // счётчик для задержки фильтра
	reg en_cnt;           // разрешение счёта
	reg cnt_full;         // флаг окончания счёта (время фильтра прошло)
	
	//------------------------------------------------------------
	// 1. Синхронизация внешнего сигнала с системным тактом
	//------------------------------------------------------------
	// Два D-триггера, чтобы подавить метастабильность
	reg key_in_sa, key_in_sb;
	always@(posedge Clk or negedge Rst_n)
	if(!Rst_n) begin
		key_in_sa <= 1'b0;
		key_in_sb <= 1'b0;
	end
	else begin
		key_in_sa <= key_in;
		key_in_sb <= key_in_sa;	
	end
	
	//------------------------------------------------------------
	// 2. Определение фронтов сигнала
	//------------------------------------------------------------
	// Запоминаем предыдущее состояние сигнала, чтобы найти нажатие/отпускание
	reg key_tmpa, key_tmpb;
	wire pedge, nedge;  // фронт вверх и вниз

	always@(posedge Clk or negedge Rst_n)
	if(!Rst_n) begin
		key_tmpa <= 1'b0;
		key_tmpb <= 1'b0;
	end
	else begin
		key_tmpa <= key_in_sb;  // текущее состояние
		key_tmpb <= key_tmpa;   // предыдущее состояние
	end

	// Обнаружение фронтов:
	assign nedge = !key_tmpa & key_tmpb; // переход 1→0 (нажатие)
	assign pedge = key_tmpa & (!key_tmpb); // переход 0→1 (отпускание)
	
	//------------------------------------------------------------
	// 3. FSM – фильтрация дребезга
	//------------------------------------------------------------
	always@(posedge Clk or negedge Rst_n)
	if(!Rst_n) begin
		en_cnt <= 1'b0;
		state <= IDLE;
		key_flag <= 1'b0;
		key_state <= 1'b1; // по умолчанию кнопка не нажата
	end
	else begin
		case(state)
			//----------------------------------------------------
			// Состояние ожидания
			//----------------------------------------------------
			IDLE: begin
				key_flag <= 1'b0;      // нет события
				if(nedge) begin        // обнаружено нажатие
					state <= FILTER0;  // перейти к фильтрации нажатия
					en_cnt <= 1'b1;    // запустить счётчик
				end
				else
					state <= IDLE;
			end
					
			//----------------------------------------------------
			// Фильтрация нажатия
			//----------------------------------------------------
			FILTER0:
				if(cnt_full) begin     // время дребезга прошло
					key_flag <= 1'b1;  // сгенерировать импульс события
					key_state <= 1'b0;  // кнопка теперь считается "нажата"
					en_cnt <= 1'b0;
					state <= DOWN;      // перейти в состояние удержания
				end
				else if(pedge) begin   // отпущена слишком быстро — дребезг
					state <= IDLE;
					en_cnt <= 1'b0;
				end
				else
					state <= FILTER0;
					
			//----------------------------------------------------
			// Кнопка удерживается
			//----------------------------------------------------
			DOWN: begin
				key_flag <= 1'b0;
				if(pedge) begin        // обнаружено отпускание
					state <= FILTER1;  // перейти к фильтрации отпускания
					en_cnt <= 1'b1;
				end
				else
					state <= DOWN;
			end
			
			//----------------------------------------------------
			// Фильтрация отпускания
			//----------------------------------------------------
			FILTER1:
				if(cnt_full) begin     // дребезг отпуска закончился
					key_flag <= 1'b1;  // импульс события
					key_state <= 1'b1; // кнопка теперь отпущена
					state <= IDLE;
					en_cnt <= 1'b0;
				end
				else if(nedge) begin   // снова нажали во время дребезга
					en_cnt <= 1'b0;
					state <= DOWN;
				end
				else
					state <= FILTER1;
			
			//----------------------------------------------------
			// Безопасное значение по умолчанию
			//----------------------------------------------------
			default: begin 
				state <= IDLE; 
				en_cnt <= 1'b0;		
				key_flag <= 1'b0;
				key_state <= 1'b1;
			end
		endcase	
	end
	
	//------------------------------------------------------------
	// 4. Счётчик для задержки фильтрации
	//------------------------------------------------------------
	always@(posedge Clk or negedge Rst_n)
	if(!Rst_n)
		cnt <= 20'd0;
	else if(en_cnt)
		cnt <= cnt + 1'b1;   // инкремент при активном счёте
	else
		cnt <= 20'd0;        // сброс счётчика, когда не используется
	
	//------------------------------------------------------------
	// 5. Проверка завершения счёта (время фильтрации)
	//------------------------------------------------------------
	always@(posedge Clk or negedge Rst_n)
	if(!Rst_n)
		cnt_full <= 1'b0;
	else if(cnt == 20'd999_999) // 1 млн циклов при 50 МГц ≈ 20 мс
		cnt_full <= 1'b1;        // время фильтрации достигнуто
	else
		cnt_full <= 1'b0;	

endmodule
